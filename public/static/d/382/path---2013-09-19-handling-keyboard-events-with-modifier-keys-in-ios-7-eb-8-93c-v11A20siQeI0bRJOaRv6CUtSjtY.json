{"data":{"site":{"siteMetadata":{"title":"A Blog","author":"Scott Williams"}},"markdownRemark":{"id":"79287a28-1067-5da6-85a9-55a7dc96503b","excerpt":"Before iOS 7, if you had a Bluetooth keyboard attached to your iPad, you could only access modifier keys (Command, Control, etc) through  private APIs . You…","html":"<p>Before iOS 7, if you had a Bluetooth keyboard attached to your iPad, you could only access modifier keys (Command, Control, etc) through <a href=\"http://stackoverflow.com/questions/14791056/ios-how-to-detect-the-escape-control-keys-on-a-hardware-bluetooth-keyboard\">private APIs</a>. You could sneak it in through <a href=\"http://stackoverflow.com/a/14940898/736\">selector trickery</a> and allegedly Apple would turn a blind eye. Fortunately with iOS 7, there’s now a public API to do this.</p>\n<p>First, let’s talk a bit about the <a href=\"https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\">Responder Chain</a>. This is how events are managed in iOS. Most of the <code class=\"language-text\">UIKit</code> classes you use inherit from <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/UIResponder\"><code class=\"language-text\">UIResponder</code></a> which means that you’ll have access to the appropriate methods. This means that you can set the scope for your keyboard shortcuts at any level in the app. I wanted to use have them registered for the entire app, so I subclassed <a href=\"https://developer.apple.com/library/ios/DOCUMENTATION/UIKit/Reference/UIApplication_Class/Reference/Reference.html\"><code class=\"language-text\">UIApplication</code></a>, though you could use a similar approach in a view or the view controller too:</p>\n<div class=\"gatsby-highlight\" data-language=\"objc\"><pre class=\"language-objc\"><code class=\"language-objc\">// STWApplication.h\n@interface STWApplication : UIApplication {\n  NSMutableArray *_commands;\n}\n\n// STWApplication.m\n@implementation STWApplication\n// more coming soon\n@end</code></pre></div>\n<p>Since we’re subclassing <code class=\"language-text\">UIApplication</code>, edit <code class=\"language-text\">main.m</code> to tell it that we’re doing so in <code class=\"language-text\">UIApplicationMain</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"objc\"><pre class=\"language-objc\"><code class=\"language-objc\">int main(int argc, char *argv[]) {\n  @autoreleasepool {\n    NSString *appName = @&quot;STWApplication&quot;;\n    return UIApplicationMain(argc, argv, appName, NSStringFromClass([STWAppDelegate class]));\n  }\n}</code></pre></div>\n<p>Ok, now let’s tell the app what key combinations are valid. iOS 7 adds a <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/Reference/Reference.html#//apple_ref/occ/instp/UIResponder/keyCommands\"><code class=\"language-text\">keyCommands</code></a> property to UIResponder. All we need to do is override that and returning an array of <a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKeyCommand_class/Reference/Reference.html#//apple_ref/occ/cl/UIKeyCommand\"><code class=\"language-text\">UIKeyCommands</code></a>. Since we’re using a <code class=\"language-text\">UIApplication</code> subclass, add this in there:</p>\n<div class=\"gatsby-highlight\" data-language=\"objc\"><pre class=\"language-objc\"><code class=\"language-objc\">- (NSArray *)keyCommands {\n  if (!_commands) {\n    UIKeyCommand *commandF = [UIKeyCommand keyCommandWithInput:@&quot;f&quot;\n                   modifierFlags:UIKeyModifierCommand\n                          action:@selector(handleShortcut:)];\n    _commands = [[NSMutableArray alloc] initWithArray:@[commandF]];\n  }\n  return _commands;\n}</code></pre></div>\n<p>Every time a keyboard event is raised, if it matches <kbd>⌘F</kbd>, the selector <code class=\"language-text\">handleShortcut</code> will be called on the responder chain. That means you can define that method multiple times and only the most specific will be called. For example, if you defined it in <code class=\"language-text\">STWApplication</code> and in the View Controller, the <code class=\"language-text\">STWApplication</code> version will <em>never</em> be called. Speaking of <code class=\"language-text\">handleShortcut</code>, here it is:</p>\n<div class=\"gatsby-highlight\" data-language=\"objc\"><pre class=\"language-objc\"><code class=\"language-objc\">- (void)handleShortcut:(UIKeyCommand *)keyCommand {\n  NSLog(@&quot;You pressed ⌘F! Good Job!&quot;);\n}</code></pre></div>\n<p><code class=\"language-text\">UIKeyCommand</code> is pretty neat. The <a href=\"https://developer.apple.com/library/ios/documentation/uikit/reference/UIKeyCommand_class/Reference/Reference.html#//apple_ref/doc/c_ref/UIKeyModifierFlags\"><code class=\"language-text\">modifierFlags</code></a> means that the app can watch for Caps Lock, Shift, Control, Alt/Option, Command, and the Number Pad. Additionally, there are some constants that  can be used for special keys like the arrows and Escape. The <a href=\"\">developer forums</a> also had some people getting access to Tab and Return by looking for <code class=\"language-text\">\\t</code> and <code class=\"language-text\">\\r</code>, but I don’t know how well those work.</p>\n<p>Also, make sure you aren’t trying to override system shortcuts. Per the docs: “Key commands that map to known system events (such as cut, copy and paste) are automatically routed to the appropriate responder methods.” So don’t do that.</p>\n<p>Now, remember how I said “every time a keyboard event is raised”? These events will only happen when a text input is the first responder. This means that if you want to have some fancy global shortcuts (say ⌘F to jump to a search box) you’ll still need to do a trick with <code class=\"language-text\">UITextField</code> (or similar). That’s a little beyond the scope of this article, but the gist is add a UITextField to a view, hide it, and make sure it stays first responder when appropriate in order to keep firing off those events.</p>\n<p>I for one am psyched that this is now available. It’s definitely more of a power user feature, but those of us who like to use Bluetooth keyboards with our iPads will derive tremendous benefit from it.</p>","frontmatter":{"title":"Handling Bluetooth Keyboard Events With Modifier Keys in iOS 7","date":"September 19, 2013"}}},"pageContext":{"slug":"/2013/09/19/handling-keyboard-events-with-modifier-keys-in-ios-7/","previous":{"fields":{"slug":"/2013/09/11/thoughts-on-the-new-iphone/"},"frontmatter":{"title":"Thoughts on the New iPhone"}},"next":{"fields":{"slug":"/2013/12/02/the-frustrations-of-the-journeyman/"},"frontmatter":{"title":"The Frustrations of the Journeyman"}}}}