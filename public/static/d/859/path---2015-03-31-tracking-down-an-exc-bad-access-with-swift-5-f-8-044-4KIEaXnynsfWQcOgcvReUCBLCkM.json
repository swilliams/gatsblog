{"data":{"site":{"siteMetadata":{"title":"A Blog","author":"Scott Williams"}},"markdownRemark":{"id":"d00e01f1-5511-5d0d-bd40-860c1da34d71","excerpt":"Managing memory has become easier. Things like  ARC  take away much of  what was once a painful and bug-ridden task. Things are not always panacea of course; it…","html":"<p>Managing memory has become easier. Things like <a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html\">ARC</a> take away much of  what was once a painful and bug-ridden task. Things are not always panacea of course; it is still far too possible to do the wrong thing and access memory you are not supposed to and receive the dreaded <code class=\"language-text\">EXC_BAD_ACCESS</code> error. </p>\n<p>Today I was working on a project in Swift. And despite my <a href=\"\">appreciation</a> of the language, the tooling still remains… <em>suspect</em>. I have covered that topic a <a href=\"http://blog.swilliams.me/2015/01/21/the-madness-of-errors-in-swift/\">couple</a> of <a href=\"http://blog.swilliams.me/2014/10/30/dealing-with-xcode-and-swift/\">times</a> before.</p>\n<p>Sometimes it’s obvious where the problem is based on the call-stack. This time it was not so obvious. The problem occurred at the end of a series of steps in a wizard when all the prior screens were finally being released from memory. From what I could tell the error was when one of the view controllers that represented one of the steps in the wizard was being deinitialized, but otherwise I couldn’t immediately see where the problem was.</p>\n<p>In Objective C you can turn on what’s called <a href=\"https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/MemoryManagementforYourApp/MemoryManagementforYourApp.html\">“NS Zombies” mode</a>, which keeps objects allocated (as a special “Zombie” object) and then raises warnings you try to access one of those Zombie objects. In my experience this has not worked quite was well with Swift. With Zombies mode enabled the app ran fine without crashing, but also didn’t raise any warnings about accessing bad memory. It was a <a href=\"http://en.wikipedia.org/wiki/Heisenbug\">Heisenbug</a>!</p>\n<figure class=\"center\">\n    \n  <a class=\"gatsby-resp-image-link\" href=\"/static/6bd00008998a30d3977aec246e56d97a/adc74/heisenberg.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n  \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block;  max-width: 500px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAQEAAwAAAAAAAAAAAAAAAAMEAgUG/8QAFgEBAQEAAAAAAAAAAAAAAAAAAgAB/9oADAMBAAIQAxAAAAHHw7CAWtdXnKm5QFf/xAAbEAACAgMBAAAAAAAAAAAAAAABAgMRABIhE//aAAgBAQABBQKU9QtGQth9ciI9d1yzZ4wJr//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/ASP/xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAgEBPwFj/8QAHRAAAQQCAwAAAAAAAAAAAAAAEQABAhASIjJBYf/aAAgBAQAGPwLCBPa2aQr2uTIphX//xAAcEAEAAwACAwAAAAAAAAAAAAABABEhMUEQUbH/2gAIAQEAAT8hV4B0JYbjqIDTpezhbPpiwuAXr4gq22egWXO8n//aAAwDAQACAAMAAAAQJx9+/8QAGBEAAgMAAAAAAAAAAAAAAAAAABEBEDH/2gAIAQMBAT8QwxEV/8QAFxEBAAMAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAgEBPxA1Nf/EAB0QAQADAAMAAwAAAAAAAAAAAAEAESExUWFBgcH/2gAIAQEAAT8QHomaNcthYW2HcgKCk8Y+OKzw+upQdXHihR+pNkYdj+YBjuo7SZ//2Q==&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\" alt=\"Heisenberg\" title=\"\" src=\"/static/6bd00008998a30d3977aec246e56d97a/adc74/heisenberg.jpg\" srcset=\"/static/6bd00008998a30d3977aec246e56d97a/e40b4/heisenberg.jpg 148w,\n/static/6bd00008998a30d3977aec246e56d97a/ead33/heisenberg.jpg 295w,\n/static/6bd00008998a30d3977aec246e56d97a/adc74/heisenberg.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\">\n    </span>\n  </span>\n  \n  </a>\n    \n    <figcaption>Eh, close enough</figcaption>\n</figure>\n<p>Next I started to play around with the code thinking that I was improperly handling the lifecycle of some of the properties of several classes. I changed around some lazy properties and made certain other things optional, but this was just wheel spinning.</p>\n<p>I backed up and reviewed the callstack again. The last frame before explosion was now at <code class=\"language-text\">swift_unknownWeakRelease</code> in a helper class referenced by the offending ViewController. This helper had this property:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// SearchBarHelper.swift\nprivate unowned let searchBar: UISearchBar</code></pre></div>\n<p>I then re-checked the <a href=\"https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html\">documentation for <code class=\"language-text\">unowned</code></a>.</p>\n<blockquote>\n<p>If you try to access an unowned reference after the instance that it references is deallocated, you will trigger a runtime error. Use unowned references only when you are sure that the reference will always refer to an instance.</p>\n</blockquote>\n<blockquote>\n<p>Note also that Swift guarantees your app will crash if you try to access an unowned reference after the instance it references is deallocated. You will never encounter unexpected behavior in this situation. Your app will always crash reliably, although you should, of course, prevent it from doing so.</p>\n</blockquote>\n<p>That <code class=\"language-text\">searchBar</code> was originally defined as an <code class=\"language-text\">IBOutlet</code> on the ViewController:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// ViewController.swift\n@IBOutlet weak var searchBar: UISearchBar!</code></pre></div>\n<p>The lights turned on. <em>Of course</em> it was crashing. An outlet that’s a weak property can and will be deallocated when the controller referencing it is no longer visible. I forgot about that when I created the other class to manage certain characteristics about that search bar. So, the <code class=\"language-text\">searchBar</code> was released at some point, and when the helper was next called (in deallocation) part of its representation in memory was an <code class=\"language-text\">unowned</code> property that was nil, a state it cannot be in. Thus, <code class=\"language-text\">EXC_BAD_ACCESS</code>.</p>\n<p>The solution was simple, I still didn’t want <code class=\"language-text\">SearchBarHelper</code> to have ownership of the <code class=\"language-text\">searchBar</code>, so I changed it to a weak optional.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// SearchBarHelper.swift\nprivate weak var searchBar: UISearchBar?</code></pre></div>\n<p>Success! </p>\n<p>Takeaway lesson: read and understand the documentation. Memory and how it is handled is still something that absolutely must be understood if you want to manage it well.</p>","frontmatter":{"title":"Tracking Down an EXC_BAD_ACCESS in Swift","date":"March 31, 2015"}}},"pageContext":{"slug":"/2015/03/31/tracking-down-an-exc-bad-access-with-swift/","previous":{"fields":{"slug":"/2015/03/22/the-woe-of-newspapers/"},"frontmatter":{"title":"The Woe of Newspapers"}},"next":{"fields":{"slug":"/2015/04/01/two-factor-authentication-for-github/"},"frontmatter":{"title":"Two Factor Authentication for GitHub"}}}}